# 스테이트풀셋

스테이트풀을 관리하는 리소스.

파드 집합의 배포와 스케일링을 관리하며, 파드들의 순서 및 고유성을 보장한다.

동일한 컨테이너 스펙의 파드를 관리한다는 점에서는 디플로이먼트와 유사하지만,

각 파드의 독자성을 유지한다는 점에선 다르다.

## 용도

1. 안정된, 고유한 네트워크 식별자
2. 안정된, 지속성을 갖는 스토리지
3. 순차적인, 정상배포와 스케일링
4. 순차적인, 자동 롤링 업데이

`안정된`은 스케줄링 전반에 걸친 지속성, 즉, 중단없는 서비스 제공을 의미한다.

순차적인 배포, 삭제, 스케일링이 필요한 상황이 아니라면, 레플리카셋(스테이트리스: stateless)을 사용하는 것이 좋다.

### stateless vs stateful

stateless는 말 그대로 상태를 저장하지 않는 특성을 의미하며, 모든 요청을 일회성으로 판단하며

같은 요청이 반복되더라도 그 상태를 기억하지 않으므로, 모두 다른 요청이라고 보는 특성이다.

대표적으로 HTTP 통신이 있다.

stateful은 반대로 사전 상태를 기억하고 요청의 시퀀스를 기억하는 특성을 의미한다.

## 제한 사항

* 파드에 지정된 저장소는 **PV Provisioner**기반의 storage class로 프로비전하거나 사전에 프로비전되어야 한다.

    즉, 공유되는 저장소 공간이 확보되어 있어야한다. 
* 스테이트풀셋이 삭제되거나 스케일 다운되어도 연관된 볼륨은 삭제되지 않는다.

    데이터의 안전을 보장하기 위함이다.
* 헤드리스 서비스가 필요하다. 사용자는 반드시 해당 서비스를 사전에 생성해야한다.
* 스테이트풀셋을 삭제한다면 생성된 파드의 종료에 대한 보장을 하지 않는다.

    만약 오작동을 예방하기 위함이라면 스케일을 0으로 세팅한 뒤 삭제한다.

### 헤드리스 서비스(Headless Service)

`spec.clusterIP` 필드가 None으로 세팅된 서비스를 의미한다.

이렇게 생성된 서비스는 클러스터 IP가 할당되지 않지만 DNS가 자동으로 구성되게 할 수 있다.

`spec.selector` 필드를 정의하여 특정 리소스에 종속시키면 연결된 리소스를 직접 가리키는 **DNS A RECORD**가 생성되며,

만약 셀럭터가 없더라도 ExternalName타입 서비스에서 사용가능한 CNAME 레코드가 생성된다.

## Menifest 

### 파드 셀렉터

`spec.selector`에 스테이트풀셋이 관리할 파드와 일치되는 label을 정의한다.

따라서 위의 값은 반드시 `spec.template.metadata.labels`와 일치해야 한다.

### VC 템플릿

`spec.volumeClaimTemplates` 필드를 통해 저장소를 프로비저닝하여 할당받을 수 있다.

### 최소 준비 시간(초)

`spec.minReadySeconds` 필드는 **사용가능(available)** 상태라고 판단될 수 있도록 관리되는 모든 파드가 문제없이 실행되어야 하는 

최소대기 시간을 의미한다.

## 파드

### 고유한 네트워크 신원 

N개의 레플리카를 갖는 스테이트풀셋은 **0 ~ N-1**까지의 정수가 순서대로 할당된다.

즉, `${statefulset_name}-${index}`형태의 이름을 갖는다.

이로서 각각의 파드이름이 고유하기 때문에 헤드리스 서비스를 통해 각 파드로의 엔드포인트 접근이 가능하다.

서비스가 관리하는 도메인의 이름은 `${service_name}.${namespace}.svc.cluster.local`의 형식이다.

생성 직후에는 DNS 캐싱등으로 인해 바로 통신이 안될 수도 있다.

생성 즉시 파드를 검색해야 할 경우, 아래와 같은 방법으로 해결가능하다.

* k8s API를 직접 쿼리
* DNS 캐싱시간 감축

### 안정된 저장소

`spec.volumeClaimTemplates` 필드를 통해 PV를 각각 생성한다. 

이렇게 생성된 PV는 스테이트풀셋이 삭제되더라도 삭제되지 않는다.

**반드시 수동으로 삭제해야한다.**

### 파드이름 레이블

스테이트풀셋 컨트롤러는 파드 생성시 파드이름으로 `statefulset.kubernetes.io/pod-name`레이블을 추가한다.

이를 통해 특정 파드에 서비스를 연결할 수 있다.

## 배포와 스케일링 보장

* 파드들을 배포할 때 연속해서 **0 ~ N-1**의 순서로 생성한다.
* 파드를 삭제할 때는 생성순서의 역순(N-1 ~ 0)으로 진행된다.
* 모든 스케일링 작업은 선행파드가 **Running 또는 Ready**상태여야 한다.
* 종료되기 전에는 후속파드가 완전히 종료되어야 한다.

위 특징을 정리하자면

web-1 파드는 web-0 파드의 상태가 Running 또는 Ready상태가 아니라면 배포되지 않으며, web-2 파드의 배포가 시작되기 전

web-0이 실패한다면 web-2는 web-0의 상태가 안정되기 전까지 배포되지 않는다.

스케일 다운의 경우 web-2가 가장 먼저 삭제되며, web-1은 web-2가 완전히 삭제되기 전까지 삭제작업을 수행하지 않는다.

web-1이 종료되기전 web-0이 실패한다면 web-1은 web-0의 상태가 안정되기 전까지 삭제를 수행하지 않는다.

이런 특징을 통해 stateful한 특성을 보장한다.

## 업데이트 전략

.spec.updateStrategy 필드를 설정하여 스테이트풀셋의 업데이트 전략을 설정할 수 있다.

### onDelete(삭제시)

`.spec.updateStrategy.type`을 **onDelete**로 설정하며 스테이트풀셋의 파드는 자동으로 업데이트되지 않는다.

사용자가 직접 파드를 삭제해야 업데이트가 이루어진다.

### RollingUpdate(롤링 업데이트)

스테이트풀셋의 파드에 대한 롤링 업데이트를 지원한다. 따로 지정된 타입이 없다면 기본값이다.

## 롤링 업데이트

`.spec.updateStrategy.type`에 **rollingUpdate**를 세팅하면 스케일링 순서에 맞게 자동으로 업데이트가 진행되며,

`.spec.minReadySeconds`를 설정한 경우 해당 시간만큼 추가적으로 대기 후에 스케일링 또는 업데이트를 진행한다.

### 파티션 롤링 업데이트

`.spec.updateStrategy.rollingUpdate.partition`을 명시하면 명시된 값보다 크거나 같은 모든 파드가 업데이트된다.

파티션 값보다 작은 수를 가진 파드는 업데이트 되지 않는다.

일반적인 경우에는 사용할 필요가 없지만, 카나리(canary) 롤아웃이나 단계적 롤아웃을 진행할 때 유용하다.

### 강제 롤백

기본 파드 관리 정책(**OrderedReady**)와 함께 롤링업데이트를 사용하면 수동 복구를 해야할 상황이 발생할 수 있다.

오류 상태인 스테이트풀셋이 무한대기상태에 있을 경우 오류가 발생한 템플릿을 수정하더라도 업데이트가 이루어지지 않는다.

이 경우 직접 대기상태인 파드를 삭제하면, 수정된 템플릿으로 파드가 재생성된다.

## PV Retain

`.spec.persistentVolumeClaimRetentionPolicy`필드는 스테이트풀셋의 라이프사이클동안 PVC를 삭제할 것인지, 삭제 방법등을 관리한다.

이 필드를 사용하려면 `StatefulSetAutoDeletePVC` 기능게이트를 활성화 해야한다.

1. `whenDeleted`

    스테이트풀셋이 삭제될때 PVC를 Retention한다.

2. `whenScaled`

    스테이트풀셋의 스케일 다운 시 PCV를 Retention한다.

위 정책들에 대해 두 가지의 값을 설정할 수 있다.

1. `Delete`

    스테이트풀셋을 통해 생성된 PVC는 모두 삭제된다. **whenDeleted**가 세팅되어 있으면 모든 PVC는 모든 파드가 삭제된 후 제거되며,
    **kwhenScaled**일때는 스케일 다운되는 파드가 삭제된 후 해당되는 PVC만 제거된다.
 
2. `Retain(기본값)`

    파드가 삭제되어도 생성된 PVC는 제거되지 않는다.

**핵심은 위 작업들이 삭제 또는 스케일 다운에만 영향을 받으며 적용된다는 점이다.**

스테이트풀셋 컨트롤러는 위 작업들을 위해 정책정보가 세팅되면 소유자 정보를 PVC에 기록한다.

이를 통해 컨트롤러가 강제 종료되어 재시작되어도 어떤 파드도 삭제되지 않음을 보장한다.

```yaml
apiVersion: apps/v1
kind: StatefulSet
...
spec:
  persistentVolumeClaimRetentionPolicy:
    whenDeleted: Retain
    whenScaled: Delete
...
```


